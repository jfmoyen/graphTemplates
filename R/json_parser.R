#############################################
#
## The json parser and its subcomponents ####
#
#############################################


#### Top-level json parser ####
###############################

parseJsonTemplate <-function(json,path=NULL,...){
  #' Parse a template loaded from json, converting the options as required
  #'
  #' This function combines a "raw" list, loaded from json file, with user options.
  #' It performs the required modifications, such as changing colours or
  #' removing elements, and returns a properly formatted graphTemplate object.
  #'
  #' @param json Name of the template file (if the .json extension is missing, it will be added automatically)
  #' @param path Path to json file. By default the package files.
  #' @param meta the names of the fields from the json file that should be kept as meta
  #' @param ... further options to be processed, see \link{make_single_template}
  #' @details
  #' This is a thin wrapper on make_single_template. It main job is to decide whether
  #' we are looking at a single plot, or a plate, and send the template or templates
  #' to make_single_template
  #'
  #' @returns a graphTemplate object.
  #'
  #' @export

  # Get the template
  tpl_raw <- load_json_file(json,path)

  if(tpl_raw$diagramType == "plate"){
    # # Several diagrams, that need to be treated in turn
    # nbslots <- length(tpl$plateSlots)
    # ee <- lapply(1:nbslots, function(i) {
    #   component <- tpl$plateSlots[i]
    #   foo <- load_json_file(component,path)
    #   process_options(foo,...)
    # })
    # class(ee)<- c("plate","graphTemplate")
  }else{
    # Any other type is only one diagram
    tpl <- make_single_template(tpl_raw,...)
  }

  # Global template description options

  return(tpl)
}


#### Internal functions ####
############################

#### Load json template ####

load_json_file<-function(json,path=NULL){
  #' Reads a json template file into a list
  #'
  #' @description A graphTemplate can be defined as a json file. This function
  #' load a json (from package's directory or user-supplied location),
  #' performs some basic syntaxic checks and returns a list for further processing.
  #'
  #' @param json Name of the template file (if the .json extension is missing, it will be added automatically)
  #' @param path Path to json file
  #' @details
  #' If no path is supplied, the function will look in the json_template
  #' directory of the package folder, and its subdirectories. It will return
  #' the first match, starting by the top-level folder and exploring
  #' sub-folders alphabetically.
  #'
  #' @importFrom jsonlite read_json
  #' @export


  ## If no path is defined, look for the template in template dir & sub-dir
  if(is.null(path)){
    toc <- list.dirs(system.file("json_templates",package="graphTemplates"))
    for(i in (1:length(toc) )){
      ii <- paste(toc[i],json,sep="/")
      if(file.exists(ii)){ thejson <- ii; break() }
      ii <- paste(toc[i],paste0(json,".json"),sep="/")
      if(file.exists(ii)){ thejson <- ii; break() }
    }

  }else{
    thejson<-paste(path,json,sep="/")
  }

  graphDef<-jsonlite::read_json(thejson,simplifyVector = T)

  ### Check the validity of the json

  # All switches must have defaults
  if( !is.null(graphDef$optionDefaults)){
    if( !all.equal(sort(names(graphDef$optionDefaults)),
                   sort(names(graphDef$optionSwitches))
                   ) ){
      stop("Error in json template:\n
           all switches MUST have defaults")
    }
  }

  # Other syntaxic checks ?
  # ...

  return(graphDef)
}

#### Convert the input list into a graphTemplate ####
make_single_template <- function(tpl_raw,
                                 meta=c("details","reference","url","templateAuthor","templateConversion","templateHistory"),
                                 template_options=NULL,
                                 transform_options=NULL,
                                 style_options=c("colDefault"="black",
                                                 ltyDefault="solid",
                                                 lwdDefault=1),
                                 doFilter=T){
  #' Convert a raw list into a proper graphTemplate
  #'
  #' @param tpl_raw a list, that will be converted to a graphTemplate.
  #' Probably loaded from json, using \link{load_json_file}
  #' @param meta the names of the fields from the input list that should be kept as meta
  #' @param template_options Named vector. They contain the switches to activate, or desactivate,
  #' controlling the display of some graph elements (see \link{jsonDiagramFormat}).
  #' @param transform_options Additional parameters to pass to the data transformation function
  #' @param style_options Options to control the styling of some elements of the template (see \link{jsonDiagramFormat}).
  #' @param doFilter if the template contains a filter (eg SiO2 > 45), should we respect it?
  #'
  #' @export

  # Prepare the switching options
  switching_options <- unlist(tpl_raw$optionDefaults)
  switching_options[names(template_options)]<-template_options[names(template_options)]

  # Prepare the styling options
  # Default is what is found in the template, overidden by user
  # Note that we include de fact a default value!
  st_opt <- unlist(tpl_raw$styleDefaults)
  st_opt[names(style_options)] <- style_options[names(style_options)]

  # Prettify the template
  template_nice <- process_template_options(tpl_raw$template,switching_options,st_opt)

  # Assemble the return object
  gt <- graphTemplate(
    Rdialect = tpl_raw$RDialect,
    axesDefinition = tpl_raw$axesDefinition,
    axesName = tpl_raw$axesName,
    limits = tpl_raw$limits,
    template = template_nice,
    diagramType = tpl_raw$diagramType,
    dataFilter = if(doFilter){tpl_raw$dataFilter}
  )

  ## Add the missing bits
  # Metadata etc
  meta <- intersect(meta,names(tpl_raw))

  # Include in template
  gt$meta <- tpl_raw[meta]

  # Name
  if(is.null(tpl_raw$name)){gt$name<-""}else{gt$name<-tpl_raw$name}
  if(is.null(tpl_raw$fullName)){gt$fullName<-""}else{gt$fullName<-tpl_raw$fullName}

  # A better definition of log
  if(is.null(tpl_raw$log)){gt$log<-""}else{gt$log<-tpl_raw$log}

  # Construct the data transform function
  gt <- add_datatransform(gt, tpl_raw$dataTransform, tpl_raw$dataTransformParams, transform_options )

  return(gt)
}

#### Modify a template based on options ####
process_template_options<-function(tpl_objects,
                                   switching_options=NULL,
                                   style_options=c("colDefault"="black",
                                                   ltyDefault="solid",
                                                   lwdDefault=1)){
  #' Internal function, modifies a template based on user options
  #'
  #' @param tpl_objects A list containing elements that can be interpreted as templateElement
  #' @param template_options Named vector. They contain the switches to activate, or desactivate,
  #' controlling the display of some graph elements (see \link{jsonDiagramFormat}).
  #' @param style_options Options to control the styling of some elements of the template (see \link{jsonDiagramFormat}).
  #' @details each element of the input list will be converted into a templateElement object.
  #' If it is switched "off", it will be removed. If appropriate, its properties
  #' (col, lty and lwd) will be modified.
  #'
  #' @returns a list of templateElement, modified and "filtered" as required
  #' @export

  # Prettify each template element
  if(is.null(tpl_objects)){
    template_nice <- NULL
  }else{
    template_nice<-lapply(tpl_objects,
                          function(z){
                            class(z)<-c("templateElement",class(z))
                            zz<-styleTemplateElement(z,style_options)
                            zzz<-showTemplateElement(zz,switching_options)
                            return(zzz)
                          })
  }
  # Remove empty elements
  template_nice <- Filter(Negate(is.null),template_nice)

  # In the case of an empty template, return one dummy element to make Figaro happy
  if(length(template_nice)==0){
    template_nice <- list(nothing=list(plotFun=""))
  }

  return(template_nice)
}

#### Append data transformation function ####

add_datatransform <- function(tpl,
                              dataTransform=tpl$dataTransform,
                              dataTransformParams=tpl$dataTransformParams,
                              transform_options=NULL){
  #' Internal function to build and add the data transform function
  #'
  #' @param tpl a graphTemplate
  #' @param dataTransform In string form, the name of the data transform function
  #' @param transform_options optional options for the data transform function
  #' @returns a graphtemplate with data transform function
  #'
  #' @export

  if(!is.null(dataTransform)){
    #Build the function
    trfFunction<-try(get(dataTransform),silent=T)
    if(class(trfFunction)=="try-error"){
      stop(cat("Function",dataTransform,"is required but has not been found\n"))
    }
    trfParams <- dataTransformParams

    # So we have a function that returns a function that executes a function
    # (holy Molly...)
    fun <- function(trfParams,transform_options){
      function(wrdata) {
        args <- c(list(wrdata),trfParams,transform_options)
        do.call(trfFunction,args=args )
      }
    }

    # Include it in the object (at least we execute one...)
    tpl$dataTransform <- fun(trfParams,transform_options)
  }

  return(tpl)
}

